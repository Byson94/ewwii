<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js navy">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Ewii documentation</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded "><a href="getting_started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.1.</strong> Installation</a></li></ol></li><li class="chapter-item expanded "><a href="config/config_and_syntax.html"><strong aria-hidden="true">2.</strong> Configuration &amp; Syntax</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="config/configuration.html"><strong aria-hidden="true">2.1.</strong> Configuration</a></li><li class="chapter-item expanded "><a href="config/config_fundamentals.html"><strong aria-hidden="true">2.2.</strong> Fundamentals</a></li><li class="chapter-item expanded "><a href="config/variables.html"><strong aria-hidden="true">2.3.</strong> Variables</a></li></ol></li><li class="chapter-item expanded "><a href="theming_and_ui.html"><strong aria-hidden="true">3.</strong> Theming &amp; UI</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="working_with_gtk.html"><strong aria-hidden="true">3.1.</strong> GTK Theming</a></li><li class="chapter-item expanded "><a href="styling_widgets.html"><strong aria-hidden="true">3.2.</strong> Styling Widgets</a></li></ol></li><li class="chapter-item expanded "><a href="widgets/widgets.html"><strong aria-hidden="true">4.</strong> Widgets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="widgets/defining_widgets.html"><strong aria-hidden="true">4.1.</strong> Defining Widgets</a></li><li class="chapter-item expanded "><a href="widgets/layouts.html"><strong aria-hidden="true">4.2.</strong> Window Layouts</a></li><li class="chapter-item expanded "><a href="widgets/props.html"><strong aria-hidden="true">4.3.</strong> Widget Properties</a></li></ol></li><li class="chapter-item expanded "><a href="examples/examples.html"><strong aria-hidden="true">5.</strong> Examples</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="examples/common_layouts.html"><strong aria-hidden="true">5.1.</strong> Common Layouts</a></li><li class="chapter-item expanded "><a href="examples/interactive.html"><strong aria-hidden="true">5.2.</strong> Interactive Widgets</a></li><li class="chapter-item expanded "><a href="examples/theming.html"><strong aria-hidden="true">5.3.</strong> Theming Tricks</a></li></ol></li><li class="chapter-item expanded "><a href="troubleshooting.html"><strong aria-hidden="true">6.</strong> Troubleshooting</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Ewii documentation</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                        <a href="https://github.com/byson94/ewwii/tree/master/docs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                        

                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="ewwii---widgets-for-everyone-made-easy"><a class="header" href="#ewwii---widgets-for-everyone-made-easy">Ewwii - Widgets for everyone made easy!</a></h1>
<p>Ewwii (ElKowar's Wacky Widgets improved interface)
is a widget system made in <a href="https://www.rust-lang.org/">Rust</a>,
which lets you create your own widgets similarly to how you can in AwesomeWM.
The key difference: It is independent of your window manager!</p>
<p>Ewwii is configured in <a href="https://rhai.rs/">Rhai</a>
and themed using <a href="https://en.wikipedia.org/wiki/CSS">CSS</a>
or <a href="https://en.wikipedia.org/wiki/Sass_(style_sheet_language)">SCSS</a>,
it is easy to customize and is powerful and dynamic.
The main goal of Ewwii is to make configuration easy
and to give the user all the power that they need.</p>
<p>Rhai is not just a basic markup language. It is a full embeddable scripting language!
This makes ewwii's configuration even more flexible and powerful.</p>
<p>Ewwii is built for users who want:</p>
<ul>
<li>Easy configuration syntax</li>
<li>Built-in configuration libraries</li>
<li>Powerful expression and <a href="https://en.wikipedia.org/wiki/Control_flow">control flow</a></li>
<li>Fully customizable widget-based UIs</li>
<li>Dynamic interfaces that respond to system state</li>
</ul>
<p>Whether you're building a tiling-friendly status bar, a floating dashboard, or a themed control panel, Ewwii gives you the tools to design it, script it, and make it your own.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>Getting starting with Ewwii. This section will cover how you can install and use ewwii.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>The first step of using Ewwii is installing it. You would need to have the following prerequesties installed on your system to build/install ewwii.</p>
<p><strong>Prerequesties:</strong></p>
<ul>
<li>rustc</li>
<li>cargo</li>
</ul>
<p>Rather than with your system package manager,
I <strong>strongly</strong> recommend installing it using <a href="https://rustup.rs/">rustup</a>.</p>
<p>Additionally, eww requires some dynamic libraries to be available on your system.
The exact names of the packages that provide these may differ depending on your distribution.
The following list of package names should work for arch linux:</p>
<details>
<summary><strong>Packages (click here)</strong></summary>
<ul>
<li>gtk3 (libgdk-3, libgtk-3)</li>
<li>gtk-layer-shell (only on Wayland)</li>
<li>pango (libpango)</li>
<li>gdk-pixbuf2 (libgdk_pixbuf-2)</li>
<li>libdbusmenu-gtk3</li>
<li>cairo (libcairo, libcairo-gobject)</li>
<li>glib2 (libgio, libglib-2, libgobject-2)</li>
<li>gcc-libs (libgcc)</li>
<li>glibc</li>
</ul>
</details>
<blockquote>
<p><strong>Note</strong> that you will most likely need the -devel variants of your distro's packages to be able to compile ewwii.</p>
</blockquote>
<h2 id="building"><a class="header" href="#building">Building</a></h2>
<p>Once you have the prerequisites ready, you're ready to install and build ewwii.</p>
<p>First clone the repo:</p>
<pre><code class="language-bash">git clone https://github.com/byson94/ewwii
</code></pre>
<pre><code class="language-bash">cd ewwii
</code></pre>
<p>Then build:</p>
<pre><code class="language-bash">cargo build --release --no-default-features --features x11
</code></pre>
<p><strong>NOTE:</strong>
When you're on Wayland, build with:</p>
<pre><code class="language-bash">cargo build --release --no-default-features --features=wayland
</code></pre>
<h2 id="running-ewwii"><a class="header" href="#running-ewwii">Running ewwii</a></h2>
<p>Once you've built it you can now run it by entering:</p>
<pre><code class="language-bash">cd target/release
</code></pre>
<p>Then make the Eww binary executable:</p>
<pre><code class="language-bash">chmod +x ./ewwii
</code></pre>
<p>Then to run it, enter:</p>
<pre><code class="language-bash">./ewwii daemon
./ewwii open &lt;window_name&gt;
</code></pre>
<h2 id="installing-via-package-managers"><a class="header" href="#installing-via-package-managers">Installing via package managers</a></h2>
<p>If you don't want to go through the <em>very</em> tedious task of cloning and building ewwii, you can install it using Cargo (Rust crate manager).</p>
<p>You can run the following command to install ewwii from cargo:</p>
<pre><code class="language-bash">cargo install --git https://github.com/byson94/ewwii
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="configuration--syntax"><a class="header" href="#configuration--syntax">Configuration &amp; Syntax</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="writing-your-ewwii-configuration"><a class="header" href="#writing-your-ewwii-configuration">Writing your ewwii configuration</a></h1>
<p>(For a list of all built-in widgets (i.e. <code>box</code>, <code>label</code>, <code>button</code>), see <a href="config/widgets.html">Widget Documentation</a>.)<br />
Ewwii is configured using its own language called <code>rhai</code>.
Using rhai, you declare the structure and content of your widgets, the geometry, position, and behavior of any windows,
as well as any state and data that will be used in your widgets.
Rhai is based around imparative syntax, which you may know from programming languages like C, Rust etc.
If you're using vim, you can make use of <a href="https://github.com/rhaiscript/vim-rhai">vim-rhai</a> for editor support.
If you're using VSCode, you can get syntax highlighting and formatting from <a href="https://marketplace.visualstudio.com/items?itemName=rhaiscript.vscode-rhai">vscode-rhai</a>.</p>
<p>Additionally, any styles are defined in CSS or SCSS (which is mostly just slightly improved CSS syntax).
While ewwii supports a significant portion of the CSS you know from the web,
not everything is supported, as ewwii relies on GTK's own CSS engine.
Notably, some animation features are unsupported,
as well as most layout-related CSS properties such as flexbox, <code>float</code>, absolute position or <code>width</code>/<code>height</code>.</p>
<p>To get started, you'll need to create two files: <code>ewwii.rhai</code> and <code>ewwii.scss</code> (or <code>ewwii.css</code>, if you prefer).
These files must be placed under <code>$XDG_CONFIG_HOME/ewwii</code> (this is most likely <code>~/.config/ewwii</code>).</p>
<p>Now that those files are created, you can start writing your first widget!</p>
<h2 id="creating-your-first-window"><a class="header" href="#creating-your-first-window">Creating your first window</a></h2>
<p>Firstly, you will need to create a top-level window. Here, you configure things such as the name, position, geometry, and content of your window.</p>
<p>Let's look at an example window definition:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enter([ // Add all defwindow inside enter. Enter is the root of the config.
  defwindow(&quot;example&quot;, #{
      monitor: 0,
      windowtype: &quot;dock&quot;,
      stacking: &quot;fg&quot;,
      wm_ignore: false,
      geometry: #{
        x: &quot;0%&quot;,
        y: &quot;2px&quot;,
        width: &quot;90%&quot;,
        height: &quot;30px&quot;,
        anchor: &quot;top center&quot;
      },
      reserve: #{ distance: &quot;40px&quot; side: &quot;top&quot; }
  }, root_widget())
])
<span class="boring">}
</span></code></pre></pre>
<p>Here, we are defining a window named <code>example</code>, which we then define a set of properties for. Additionally, we set the content of the window to be the text <code>&quot;example content&quot;</code>.</p>
<p>You can now open your first window by running <code>eww open example</code>! Glorious!</p>
<h3 id="defwindow-properties"><a class="header" href="#defwindow-properties"><code>defwindow</code>-properties</a></h3>
<table><thead><tr><th align="right">Property</th><th>Description</th></tr></thead><tbody>
<tr><td align="right"><code>monitor</code></td><td>Which monitor this window should be displayed on. See below for details.</td></tr>
<tr><td align="right"><code>geometry</code></td><td>Geometry of the window.</td></tr>
</tbody></table>
<p><strong><code>monitor</code>-property</strong></p>
<p>This field can be:</p>
<ul>
<li>the string <code>&lt;primary&gt;</code>, in which case ewwii tries to identify the primary display (which may fail, especially on wayland)</li>
<li>an integer, declaring the monitor index</li>
<li>the name of the monitor</li>
<li>a string containing a JSON-array of monitor matchers, such as: <code>'[&quot;&lt;primary&gt;&quot;, &quot;HDMI-A-1&quot;, &quot;PHL 345B1C&quot;, 0]'</code>. Ewwii will try to find a match in order, allowing you to specify fallbacks.</li>
</ul>
<p><strong><code>geometry</code>-properties</strong></p>
<table><thead><tr><th align="right">Property</th><th>Description</th></tr></thead><tbody>
<tr><td align="right"><code>x</code>, <code>y</code></td><td>Position of the window. Values may be provided in <code>px</code> or <code>%</code>. Will be relative to <code>anchor</code>.</td></tr>
<tr><td align="right"><code>width</code>, <code>height</code></td><td>Width and height of the window. Values may be provided in <code>px</code> or <code>%</code>.</td></tr>
<tr><td align="right"><code>anchor</code></td><td>Anchor-point of the window. Either <code>center</code> or combinations of <code>top</code>, <code>center</code>, <code>bottom</code> and <code>left</code>, <code>center</code>, <code>right</code>.</td></tr>
</tbody></table>
<br/>
Depending on if you are using X11 or Wayland, some additional properties exist:
<h4 id="x11"><a class="header" href="#x11">X11</a></h4>
<table><thead><tr><th align="right">Property</th><th>Description</th></tr></thead><tbody>
<tr><td align="right"><code>stacking</code></td><td>Where the window should appear in the stack. Possible values: <code>fg</code>, <code>bg</code>.</td></tr>
<tr><td align="right"><code>wm_ignore</code></td><td>Whether the window manager should ignore this window. This is useful for dashboard-style widgets that don't need to interact with other windows at all. Note that this makes some of the other properties not have any effect. Either <code>true</code> or <code>false</code>.</td></tr>
<tr><td align="right"><code>reserve</code></td><td>Specify how the window manager should make space for your window. This is useful for bars, which should not overlap any other windows.</td></tr>
<tr><td align="right"><code>windowtype</code></td><td>Specify what type of window this is. This will be used by your window manager to determine how it should handle your window. Possible values: <code>normal</code>, <code>dock</code>, <code>toolbar</code>, <code>dialog</code>, <code>desktop</code>. Default: <code>dock</code> if <code>reserve</code> is specified, <code>normal</code> otherwise.</td></tr>
</tbody></table>
<h4 id="wayland"><a class="header" href="#wayland">Wayland</a></h4>
<table><thead><tr><th align="right">Property</th><th>Description</th></tr></thead><tbody>
<tr><td align="right"><code>stacking</code></td><td>Where the window should appear in the stack. Possible values: <code>fg</code>, <code>bg</code>, <code>overlay</code>, <code>bottom</code>.</td></tr>
<tr><td align="right"><code>exclusive</code></td><td>Whether the compositor should reserve space for the window automatically. Either <code>true</code> or <code>false</code>. If <code>true</code> <code>:anchor</code> has to include <code>center</code>.</td></tr>
<tr><td align="right"><code>focusable</code></td><td>Whether the window should be able to be focused. This is necessary for any widgets that use the keyboard to work. Possible values: <code>none</code>, <code>exclusive</code> and <code>ondemand</code>.</td></tr>
<tr><td align="right"><code>namespace</code></td><td>Set the wayland layersurface namespace ewwii uses. Accepts a <code>string</code> value.</td></tr>
</tbody></table>
<h2 id="your-first-widget"><a class="header" href="#your-first-widget">Your first widget</a></h2>
<p>While our bar is already looking great, it's a bit boring. Thus, let's add some actual content!</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greeter(name) {
  return box(#{
    orientation: &quot;horizontal&quot;,
    halign: &quot;center&quot;
  }, [
    button(#{ onclick: &quot;notify-send 'Hello' 'Hello, ${name}'&quot;, text: &quot;Greet&quot; })
  ]);
};
<span class="boring">}
</span></code></pre></pre>
<p>To show this, let's replace the text in our window definition with a call to this new widget:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enter([
  defwindow(&quot;example&quot;, #{
    // ... properties omitted
  }, greeter(&quot;Bob&quot;))
])
<span class="boring">}
</span></code></pre></pre>
<p>There is a lot going on here, so let's step through this.</p>
<p>We are creating a function named <code>greeter</code> and a function is equal to a component that returns a child (widget). So function has two uses: one to return a component, and the other to do a set of functions.
And this function takes one parameters, called <code>name</code>. The <code>name</code> parameter <em>must</em> be provided or else, you should emit it. Rhai does allow adding optional parameters, but we will talk about it later for the sake of beginners who are in-experienced with imprative programming languages.</p>
<p>Now inside the function, we declare the body of our widget that we are returning. We make use of a <code>box</code>, which we set a couple properties of.</p>
<p>We need this <code>box</code>, as a function can only ever contain a single widget - otherwise,
ewwii would not know if it should align them vertically or horizontally, how it should space them, and so on.
Thus, we wrap multiple children in a <code>box</code>.
This box then contains a button.
In that button's <code>onclick</code> property, we refer to the provided <code>name</code> using string-interpolation syntax: <code>&quot;${name}&quot;</code>.
This allows us to easily refer to any variables within strings.</p>
<!-- TODO -->
<!-- In fact, there is a lot more you can do within `${...}` - more on that in the chapter about the [expression language](expression_language.md). -->
<p>To then use our widget, we call the function that provides the widget with the necessary parameters passed.</p>
<p>As you may have noticed, we are using a couple predefined widgets here. These are all listed and explained in the <a href="config/widgets.html">widgets chapter</a>.</p>
<h3 id="rendering-children-in-your-widgets"><a class="header" href="#rendering-children-in-your-widgets">Rendering children in your widgets</a></h3>
<p>As your configuration grows, you might want to improve its structure by factoring out pieces into reusable functions.</p>
<p>In Ewwii’s Rhai-based configuration system, you can define wrapper functions that return widgets and accept a <code>children</code> parameter, just like built-in widgets such as <code>box()</code> or <code>button()</code>.</p>
<p>Here's an example of a custom container that adds a label before its children:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn labeled_container(name, children = []) {
  return box(#{ class: &quot;container&quot; }, [label(#{text: name})] + children)
}
<span class="boring">}
</span></code></pre></pre>
<p>You can call it like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>labeled_container(&quot;foo&quot;, [
  button(#{ onclick: &quot;notify-send hey ho&quot;, text: &quot;Click me&quot; })
]);
<span class="boring">}
</span></code></pre></pre>
<p>Because children are just a list of widgets, you can also write functions that structure them however you'd like. For example, here's a layout that places the first two children side by side:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn two_boxes(children = []) {
  return box(#{}, [
    box(#{ class: &quot;first&quot; }, [children[0]]),
    box(#{ class: &quot;second&quot; }, [children[1]])
  ]);
}
<span class="boring">}
</span></code></pre></pre>
<p>And call it like this:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>two_boxes([
  label(#{ text: &quot;First&quot; }),
  label(#{ text: &quot;Second&quot; })
]);
<span class="boring">}
</span></code></pre></pre>
<p>If a child is missing (e.g., children[1] doesn't exist), make sure to handle that gracefully or document the expected number of children.</p>
<!-- TODO: add it once literal is implemented -->
<!-- ## Dynamically generated widgets with `literal`

In some cases, you want to not only change the text,
value, or color of a widget dynamically, but instead want to generate an entire widget structure dynamically.
This is necessary if you want to display lists of things (for example notifications)
where the amount is not necessarily known,
or if you want to change the widget structure in some other, more complex way.

For this, you can make use of one of ewwii's most powerful features: the `literal` widget.

```rust
let variable_containing_rhai = "(box (button 'foo') (button 'bar'))";

// Then, inside your widget, use:
literal(#{ content: variable_containing_rhai })
```

Here, you specify the content of your literal by providing it a string (most likely stored in a variable) which contains a single yuck widget tree.
Ewwii then reads the provided value and renders the resulting widget. Whenever it changes, the widget will be rerendered.

Note that this is not all that efficient. Make sure to only use `literal` when necessary! -->
<h2 id="window-id"><a class="header" href="#window-id">Window ID</a></h2>
<p>In some cases you may want to use the same window configuration for multiple widgets, e.g. for multiple windows. This is where arguments and ids come in.</p>
<p>Firstly let us start off with ids. An id can be specified in the <code>open</code> command
with <code>--id</code>, by default the id will be set to the name of the window
configuration. These ids allow you to spawn multiple of the same windows. So
for example you can do:</p>
<pre><code class="language-bash">ewwii open my_bar --screen 0 --id primary
ewwii open my_bar --screen 1 --id secondary
</code></pre>
<h2 id="generating-a-list-of-widgets-from-array-using-for"><a class="header" href="#generating-a-list-of-widgets-from-array-using-for">Generating a list of widgets from array using <code>for</code></a></h2>
<p>If you want to display a list of values, you can use the <code>for</code>-Element to fill a container with a list of elements generated from a JSON-array.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let my_array = [1, 2, 3];

// Then, inside your widget, you can use
box(#{}, [
  for entry in my_array {
    button(#{ onclick: &quot;notify-send 'click' 'button ${entry}'&quot;, text: entry.to_string() })
  }
])
<span class="boring">}
</span></code></pre></pre>
<p>This can be useful in many situations, for example when generating a workspace list from an array representation of your workspaces.
In many cases, this can be used instead of <code>literal</code>, and should most likely be preferred in those cases.</p>
<!-- To see how to declare and use more advanced data structures, check out the [data structures example](/examples/data-structures/ewwii.rhai). -->
<h2 id="splitting-up-your-configuration"><a class="header" href="#splitting-up-your-configuration">Splitting up your configuration</a></h2>
<p>As time passes, your configuration might grow larger and larger. Luckily, you can easily split up your configuration into multiple files!</p>
<p>There are two options to achieve this:</p>
<h3 id="using-include"><a class="header" href="#using-include">Using <code>include</code></a></h3>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>include(&quot;./path/to/your/file.rhai&quot;);
<span class="boring">}
</span></code></pre></pre>
<p>A single rhai file may import the contents of any other rhai file. For this, make use of the <code>include</code> directive.</p>
<h3 id="using-a-separate-ewwii-configuration-directory"><a class="header" href="#using-a-separate-ewwii-configuration-directory">Using a separate ewwii configuration directory</a></h3>
<p>If you want to separate different widgets even further, you can create a new ewwii config folder anywhere else.
Then, you can tell ewwii to use that configuration directory by passing <em>every</em> command the <code>--config /path/to/your/config/dir</code> flag.
Make sure to actually include this in all your <code>ewwii</code> calls, including <code>ewwii kill</code>, <code>eww logs</code>, etc.
This launches a separate instance of the ewwii daemon that has separate logs and state from your main ewwii configuration.</p>
<pre><code class="language-bash">ewwii --config &quot;/path/to/your/config/dir&quot;
</code></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="fundamentals"><a class="header" href="#fundamentals">Fundamentals</a></h1>
<p>Ewwii uses Rhai as its configuration language. But instead of just pure Rhai, ewwii has its own layout that users should follow to create widgets using Rhai. And you may be wondering why ewwii has a &quot;custom&quot; layout instead of allowing users to just use pure Rhai. It's good question and the reason why ewwii has a custom layout is because it tries to remove unnecessary complexity.</p>
<p>The full reasons for this layout wont be explained much more because it goes way deeper than just &quot;decreasing complexity&quot;.</p>
<p>For more information about Rhai, you can read <a href="https://rhai.rs/book/">their documentation</a>.</p>
<h2 id="widgets-and-their-parameters"><a class="header" href="#widgets-and-their-parameters">Widgets and their parameters</a></h2>
<p>Each widget in ewwii is a function (e.g: <code>button(#{...})</code> is a function call to create a button). So each one requires its own parameters.</p>
<p>For example, <code>defwindow</code> expects a <strong>String</strong>, <strong>Properties</strong>, and a function call that <strong>returns a widget.</strong></p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enter([
  // the string here (the text in &quot;&quot;) is the name of the window
  // the content in #{} is the properties
  // and the 3rd `root_widget()` call is the function that returns a child.

  // defwindow cant have children in [] directly, but it expects a function returning it for it.
  defwindow(&quot;example&quot;, #{
      monitor: 0,
      windowtype: &quot;dock&quot;,
      stacking: &quot;fg&quot;,
      wm_ignore: false,
      geometry: #{
        x: &quot;0%&quot;,
        y: &quot;2px&quot;,
        width: &quot;90%&quot;,
        height: &quot;30px&quot;,
        anchor: &quot;top center&quot;
      },
      reserve: #{ distance: &quot;40px&quot; side: &quot;top&quot; }
  }, root_widget())
])
<span class="boring">}
</span></code></pre></pre>
<p>This is not that complex once you know the parameters of defwindow as most of the other widgets only take in properties or optinally children. <strong>Poll/Listen</strong> are the only things that is similar to <code>defwindow</code> and you will learn about it later in the <a href="config/./variables.html">variables chapter</a>.</p>
<h2 id="the-root"><a class="header" href="#the-root">The root</a></h2>
<p>It is an important concept that users must know to go forward with this documentaiton. Ewwii's Rhai layout is made to be <strong>logical and powerful</strong>, so the user is given access the root of the entire widget system.</p>
<p>The root is defined as <code>enter()</code> and it is where you should write <code>defwindow</code>.</p>
<p>Here is an example:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enter([
  defwindow(&quot;example&quot;, #{
      monitor: 0,
      windowtype: &quot;dock&quot;,
      stacking: &quot;fg&quot;,
      wm_ignore: false,
      geometry: #{
        x: &quot;0%&quot;,
        y: &quot;2px&quot;,
        width: &quot;90%&quot;,
        height: &quot;30px&quot;,
        anchor: &quot;top center&quot;
      },
      reserve: #{ distance: &quot;40px&quot; side: &quot;top&quot; }
  }, root_widget())
])
<span class="boring">}
</span></code></pre></pre>
<p>Now that you saw this example, you may be wondering why we are doing <code>enter([])</code> instead of <code>enter()</code>. That is due to another fundamental concept in ewwii which is very important. You will learn about it in the <a href="config/config_fundamentals.html#properties-and-child-definition">properties and child definition section</a>.</p>
<h2 id="semi-colons"><a class="header" href="#semi-colons">Semi-colons</a></h2>
<p>Semi-colon is an important character in Rhai. Just like programming languages like JavaScript, Java, Rust etc.</p>
<p>You can use the following link to read about semi-colons in the Rhai book as they have an awesome documentation.</p>
<p><a href="https://rhai.rs/book/ref/statements.html#statements">https://rhai.rs/book/ref/statements.html#statements</a></p>
<h2 id="properties-and-child-definition"><a class="header" href="#properties-and-child-definition">Properties and child definition</a></h2>
<p>The part where most people get confused is the use of <code>[]</code> and <code>#{}</code>. Let's get into what those are and how you can use them.</p>
<p>The <code>[]</code> is used for adding <strong>children</strong> to a widget.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greeter(foo) {
  return box(#{
    orientation: &quot;horizontal&quot;,
    halign: &quot;center&quot;
  }, [
    // the `[]` holds a button which is the child widget of the box widget
    // each element in a `[]` should end in a comma (,) instead of a semi-colon (;).
    button(#{ onclick: &quot;notify-send '${foo}'&quot;, text: &quot;baz&quot; }),
    label(#{ text: &quot;example&quot; }),
  ]);
};
<span class="boring">}
</span></code></pre></pre>
<p>The <code>#{}</code> works similar to the <code>[]</code> but, it is used to add properties into the widget.</p>
<p><strong>Example:</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn greeter(foo) {
  // the `#{}` holds the properties of the box widget
  // each element in a `#{}` should end in a comma (,) instead of a semi-colon (;).
  return box(#{
    orientation: &quot;horizontal&quot;,
    halign: &quot;center&quot;
  }, [
    // properties are assigned to both button and label using the #{}.
    button(#{ onclick: &quot;notify-send '${foo}'&quot;, text: &quot;baz&quot; }),
    label(#{ text: &quot;example&quot; }),
  ]);
};
<span class="boring">}
</span></code></pre></pre>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Now that you feel sufficiently greeted by your bar, you may realize that showing data like the time and date might be even more useful than having a button that greets you.</p>
<p>To implement dynamic content in your widgets, you make use of <em>variables</em>.</p>
<p>All variables are only locally available so you would need to pass it around using function parameters. And whenever the variable changes, the value in the widget will update!</p>
<h2 id="static-variables"><a class="header" href="#static-variables">Static variables</a></h2>
<p>In Rhai, all variables are dynamically typed bindings to values. You can define variables using let, pass them as function parameters.</p>
<p><strong>Basic variables (<code>let</code>)</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = &quot;value&quot;;
<span class="boring">}
</span></code></pre></pre>
<p>This is the simplest type of variable.
Basic variables don't ever change automatically, if you need a dynamic variable, you can use built in functions like <code>poll()</code> and <code>listen()</code> to register dynamic values which we will talk about in the following section.</p>
<h2 id="dynamic-variables"><a class="header" href="#dynamic-variables">Dynamic variables</a></h2>
<p>Just having static variables that wont update is pretty limiting. So, ewwii has two built in functions to register dynamic variables that can change according to the command.</p>
<p><strong>Polling variables (<code>poll</code>)</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>poll(&quot;var_name&quot;, #{
  // It is recommended to have initial property passed.
  // If not provided, it will default to no value which may cause problems when used.
  // You can pass something like &quot;&quot; if you want no initial value.
  initial: &quot;inital value&quot;,
  interval: &quot;2s&quot;,
  cmd: &quot;date +%H:%M:%S&quot;, // command to execute
})
<span class="boring">}
</span></code></pre></pre>
<p>A polling variable is a variable which runs a provided shell-script repeatedly, in a given interval.</p>
<p>This may be the most commonly used type of variable.
They are useful to access any quickly retrieved value repeatedly,
and thus are the perfect choice for showing your time, date, as well as other bits of information such as pending package updates, weather, and battery level.
But it is important to note that these variables are locally available only in enter (a.k.a the root) and you need to pass it to other functions with something like <code>some_fn(foo)</code> when you want to use a polled variable.</p>
<!-- You can also specify an initial-value. This should prevent ewwii from waiting for the result of a given command during startup, thus
making the startup time faster. -->
<p>To externally update a polling variable, <code>ewwii update</code> can be used like with basic variables to assign a value.</p>
<p><strong>Listening variables (<code>listen</code>)</strong></p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>listen(&quot;foo&quot;, #{
  initial: &quot;whatever&quot;,
  cmd: &quot;tail -F /tmp/some_file&quot;,
})
<span class="boring">}
</span></code></pre></pre>
<p>Listening variables might be the most confusing of the bunch.
A listening variable runs a script once, and reads its output continously.
Whenever the script outputs a new line, the value will be updated to that new line.
In the example given above, the value of <code>foo</code> will start out as <code>&quot;whatever&quot;</code>, and will change whenever a new line is appended to <code>/tmp/some_file</code>.</p>
<p>These are particularly useful when you want to apply changes instantaneously when an operation happens if you have a script
that can monitor some value on its own. Volume, brightness, workspaces that get added/removed at runtime,
monitoring currently focused desktop/tag, etc. are the most common usecases of this type of variable.
These are particularly efficient and should be preffered if possible.</p>
<p>For example, the command <code>xprop -spy -root _NET_CURRENT_DESKTOP</code> writes the currently focused desktop whenever it changes.
Another example usecase is monitoring the currently playing song with playerctl: <code>playerctl --follow metadata --format {{title}}</code>.</p>
<!--
**Built-in "magic" variables**

In addition to defining your own variables, ewwii provides some values for you to use out of the box.
These include values such as your CPU and RAM usage.
These mostly contain their data as JSON, which you can then get using the [json access syntax](expression_language.md).
All available magic variables are listed [here](magic-vars.md). -->
<h2 id="passing-variables"><a class="header" href="#passing-variables">Passing variables</a></h2>
<p>As we discussed earlier, all variables are only available locally. So, you would need to pass it around from the current scope.</p>
<p>Here is an example of how it is done:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let foo = &quot;example&quot;;

poll(&quot;time&quot;, #{
  initial: &quot;inital value&quot;,
  interval: &quot;2s&quot;,
  cmd: &quot;date +%H:%M:%S&quot;,
})

// Here we have 2 variables named &quot;time&quot; (registered dynamically by poll) and foo (a static variable)

// here is an example of something that wont
fn wont_work() {
  return box(#{}, [ label(#{ text: time }), label(#{ text: foo }) ]);
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p>[!NOTE]
test</p>
</blockquote>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="theming--ui"><a class="header" href="#theming--ui">Theming &amp; UI</a></h1>
<p>This section focuses on visual styling and user interface customization. The core visual layer is built atop GTK, allowing deep integration with system themes while also enabling custom overrides through SCSS-style syntax.</p>
<p>We'll explore:</p>
<ul>
<li>How GTK theming works under the hood</li>
<li>Styling your widgets using theme classes and custom CSS</li>
<li>Layout implications of theme decisions (e.g., spacing, margins, z-order)</li>
</ul>
<p>Whether you're trying to match your system's look or building a highly customized UI, this section gives you the tools to style confidently.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="gtk-theming"><a class="header" href="#gtk-theming">GTK Theming</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="styling-widgets"><a class="header" href="#styling-widgets">Styling Widgets</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="widgets"><a class="header" href="#widgets">Widgets</a></h1>
<p>Widgets are the building blocks of your interface. Each widget represents a visual element—text, images, containers, interactive components—that can be composed, styled, and updated dynamically.</p>
<p>This section introduces:</p>
<ul>
<li>The basic anatomy of a widget definition</li>
<li>How widgets are laid out within windows</li>
<li>The attributes and properties available to each widget type</li>
<li>Patterns for building reusable or dynamic widget trees</li>
</ul>
<p>You’ll also learn how widget properties interact with the expression language and how reactivity is handled across updates.</p>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="defining-widgets"><a class="header" href="#defining-widgets">Defining Widgets</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="window-layouts"><a class="header" href="#window-layouts">Window Layouts</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="widget-properties"><a class="header" href="#widget-properties">Widget Properties</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="examples"><a class="header" href="#examples">Examples</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="common-layouts"><a class="header" href="#common-layouts">Common Layouts</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="interactive-widgets"><a class="header" href="#interactive-widgets">Interactive Widgets</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="theming-tricks"><a class="header" href="#theming-tricks">Theming Tricks</a></h1>
<div id="chapter_begin" style="break-before: page; page-break-before: always;"></div><h1 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h1>
<p>Here you will find help if something doesn't work. If the issue isn't listed here, please <a href="https://github.com/byson94/ewwii/issues">open an issue on the GitHub repo.</a></p>
<h2 id="ewwii-does-not-compile"><a class="header" href="#ewwii-does-not-compile">Ewwii does not compile</a></h2>
<ol>
<li>Make sure that you are compiling ewwii using a recent version of rust (run <code>rustup update</code> to be sure you have the latest version available)</li>
<li>Make sure you have all the necessary dependencies. If there are compile-errors, the compiler will tell you what you're missing.</li>
</ol>
<h2 id="ewwii-does-not-work-on-wayland"><a class="header" href="#ewwii-does-not-work-on-wayland">Ewwii does not work on Wayland</a></h2>
<ol>
<li>Make sure you compiled ewwii with the <code>--no-default-features --features=wayland</code> flags.</li>
<li>Make sure that you're not trying to use X11-specific features (these are (hopefully) explicitly specified as such in the documentation).</li>
</ol>
<h2 id="my-configuration-is-not-loaded-correctly"><a class="header" href="#my-configuration-is-not-loaded-correctly">My configuration is not loaded correctly</a></h2>
<ol>
<li>Make sure the <code>ewwii.rhai</code> and <code>ewwii.(s)css</code> files are in the correct places.</li>
<li>Sometimes, ewwii might fail to load your configuration as a result of a configuration error. Make sure your configuration is valid.</li>
</ol>
<h2 id="something-isnt-styled-correctly"><a class="header" href="#something-isnt-styled-correctly">Something isn't styled correctly!</a></h2>
<p>Check the <a href="working_with_gtk.html#gtk-debugger">GTK-Debugger</a> to get more insight into what styles GTK is applying to which elements.</p>
<h2 id="general-issues"><a class="header" href="#general-issues">General issues</a></h2>
<p>You should try the following things before opening an issue or doing more specialized troubleshooting:</p>
<ul>
<li>Kill the ewwii daemon by running <code>ewwii kill</code> and re-open your window with the <code>--debug</code>-flag to get additional log output.</li>
<li>Now you can take a look at the logs by running <code>ewwii logs</code>.</li>
<li>Use <code>ewwii state</code> to see the state of all variables.</li>
<li>Use <code>ewwii debug</code> to see the structure of your widget and other information.</li>
<li>Update to the latest ewwii version.</li>
<li>Sometimes hot reloading doesn't work. In that case, you can make use of <code>ewwii reload</code> manually.</li>
</ul>
<p>Remember, if your issue isn't listed here, <a href="https://github.com/byson94/ewwii/issues">open an issue on the GitHub repo</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
